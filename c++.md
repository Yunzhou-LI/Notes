### 1.c++11之constexpr与const区别
c++11中新增加了constexpr关键字，二者主要区别为：
1. const用于表示被修饰变量或函数具有只读的特性，无法修改，而constexpr用于表示被修饰变量具有“常量特性”。
2. **`constexpr`**: 表示编译时常量，它要求变量在编译时就必须能够求值，无需等到运行时计算，极大提高运行效率。而 **`const`**：表示运行时常量。  
   [点击查看const和constexpr详细区别](https://zhuanlan.zhihu.com/p/685959718)
### 2.c++四种类型转换
在编写c++代码过程中，经常用到类型转换，如父类指针或引用转换为子类指针或引用，常量地址转换为类或结构体指针等等。  
*__c++中主要有四种强制类型转换，要与C风格的类型转换相区分使用：__*  
1.**static_cast**：
 - 基本数据类型的转换（如将int类型转换为char类型）
 - 静态转换用于类层次结构中父类和子类之间指针或引用的转换。

2.**dynamic_cast**：相比于静态类型转换（如 static_cast），dynamic_cast 会在运行时进行检查，可以确保类型转换的安全性    
 - 上行转换（Upcasting）：从子类转换为父类。
 - 下行转换（Downcasting）：从父类转换为子类，且要求父类中至少有一个虚函数（即是多态类）。

3.**reinterpret_cast**：C++ 中最强大、但也最危险的类型转换操作符之一。它允许在不同类型之间进行低级别的类型转换。与其他类型转换操作符不同，reinterpret_cast 并不会进行任何类型检查，它仅仅是重新解释二进制位的含义，直接将一个类型的位模式重新解释为另一个类型。  
 - 指针类型之间的转换：将一个指针类型转换为另一个指针类型，甚至是将指针转换为整数类型（或反之）。
 - 指针和整数之间的转换：允许将指针转换为整数类型，或将整数转换为指针类型。
 - 非相关类型之间的转换：允许在不相关的类型之间进行转换，比如将 float* 转换为 int*，或者将对象类型转换为字节序列。

4.**const_cast**：const_cast 是 C++ 中专门用于 常量属性 的类型转换操作符。它的主要作用是 移除 或 添加 对象的 const 或 volatile 修饰符。  
 - 移除 const 限定符：允许将指向常量的指针或引用转换为指向非常量的指针或引用，以便修改常量对象（注意：修改真正的常量对象会导致未定义行为）。
 - 添加 const 限定符：也可以用于给指针或引用添加 const 限定符。

   [点击查看四种类型转换的用法及区别](https://blog.csdn.net/weixin_45031801/article/details/142147962)

### 3.mutable关键字

### 4.explicit关键字  

### 5.逻辑运算和按位运算  
#### 5.1 逻辑运算
**&&**：与    
**||**：或     
**~**：非
#### 5.2 按位运算
**&**：按位与    
**|**：按位或     
**~**：按位非    
**^**：异或  
**拓展1**：|=，&=，^=，~= 分别表示相应的运算后赋值  
**拓展2**：同或：C++中没有明确的同或符号，可以利用异或的结果进行取反得到，示例：return ~(a^b)  
**拓展3**：位移运算，<<左移，>>右移，<<=左移后赋值，>>=右移后赋值  
  [点击查看带示例的运算](https://www.cnblogs.com/zhangzhixi/p/13875465.html)

### 6.mmap内存映射

### 7.条件变量之wait_for() ,notify_one(),notify_all() 

### 8.静态库与动态库区别 

### 9.windows下静/动态库与linux下区别

### 10.vector动态扩容，reserve()，size()，resize()使用记录

### 11.静态变量 单例类析构时机，析构函数释放资源时机

### 12.条件编译

### 13.extern关键字

### 14.spdlog日志库

### 15.zeromq

### 16.虚函数表

一个类对象其内存分布的基本结构为**虚函数表地址+非静态成员变量**，类的成员函数不占用类对象的空间，他们分布在一片属于类的共有区域。
类的静态成员函数和静态成员变量不占用类对象的空间，他们分配在静态区。
**虚函数表的地址存储在类对象的起始位置。**所以我们利用这个原理，通过寻址的方式访问虚函数表里的函数。

虚函数表的地址根据机器的位数来决定，有的是32位，有的是64位，分别占用4字节和8字节，在有一些64位的编译器中，int占4字节，在内存中会进行补齐或对齐。

虚函数在虚函数表里存储的是函数指针。

继承中的虚函数表：当继承一个含有虚函数的类时，子类也会维护一个虚函数表，若重写了父类的虚函数，则子类的虚函数表中存储自己重写后的虚函数指针，以及未重写的父类的虚函数指针。

**多重继承**的情况就是类对象空间里存储多张虚函数表地址。子类继承于两个基类，并且基类都有虚函数，那么子类就有两张虚函数表。

**多态调用原理**：通过基类指针指向子类对象时，基类指针实际指向的是子类的空间，寻址也是找到子类的虚函数表，从虚函数表中找到子类实现的虚函数，然后调用子类版本，从而达到多态效果。

**菱形继承**：当B和C继承类A后，类D再多继承B和C，这样会导致类D维护两个A的副本，有可能数据不一致，因此B和C需要虚继承A。

**内存补齐和对齐规则**：

在考察一个类对象所占空间时，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。对象大小= vptr(虚函数表指针，可能不止一个) + 所有非静态数据成员大小 + Aligin字节大小（依赖于不同的编译器对齐和补齐）

对齐：类(结构体)对象每个成员变量分配内存的起始地址为其所占空间的整数倍。（比如4字节的int型，若在内存中的起始位置为7，7不是4的整数倍，则会对齐到8，将8作为存放int型的起始地址）
补齐：类(结构体)对象所占用的总大小为其内部最大成员所占空间的整数倍。（若某个对象实际占用内存为5字节，而其最大成员为4字节，则会补充三个字节，使该对象占8个字节，总字节数为其最大成员的整数倍）。

**一个空类也会占用一个字节的内存**，用于区分不同的类对象。





